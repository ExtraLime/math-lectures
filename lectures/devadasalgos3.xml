<?xml version="1.0" encoding="UTF-8"?>
<timedtext format="3">
<body>
<p t="80" d="1690">The following
content is provided</p>
<p t="1770" d="2240">under a Creative
Commons license.</p>
<p t="4010" d="2850">Your support will help MIT
OpenCourseWare continue</p>
<p t="6860" d="3860">to offer high quality
educational resources for free.</p>
<p t="10720" d="2610">To make a donation or
view additional materials</p>
<p t="13330" d="3898">from hundreds of MIT courses,
visit MIT OpenCourseWare</p>
<p t="17228" d="625">at ocw.mit.edu.</p>
<p t="23290" d="3720">PROFESSOR: So today's
lecture is on sorting.</p>
<p t="27010" d="4300">We'll be talking about specific
sorting algorithms today.</p>
<p t="31310" d="3260">I want to start
by motivating why</p>
<p t="34570" d="2535">we're interested in sorting,
which should be fairly easy.</p>
<p t="39690" d="2800">Then I want to discuss
a particular sorting</p>
<p t="42490" d="2980">algorithm that's
called insertion sort.</p>
<p t="45470" d="2390">That's probably the
simplest sorting algorithm</p>
<p t="47860" d="4082">you can write, it's
five lines of code.</p>
<p t="51942" d="1458">It's not the best
sorting algorithm</p>
<p t="53400" d="4030">that's out there and so
we'll try and improve it.</p>
<p t="57430" d="3040">We'll also talk about merge
sort, which is a divide</p>
<p t="60470" d="2780">and conquer algorithm
and that's going</p>
<p t="63250" d="5760">to motivate the last thing
that I want to spend time on,</p>
<p t="69010" d="3290">which is recurrences and
how you solve recurrences.</p>
<p t="72300" d="1930">Typically the
recurrences that we'll</p>
<p t="74230" d="3890">be looking at in double o six
are going to come from divide</p>
<p t="78120" d="2640">and conquer problems
like merge sort</p>
<p t="80760" d="3540">but you'll see
this over and over.</p>
<p t="84300" d="2665">So let's talk about why
we're interested in sorting.</p>
<p t="90110" d="4260">There's some fairly
obvious applications</p>
<p t="94370" d="3120">like if you want to
maintain a phone book,</p>
<p t="97490" d="4520">you've got a bunch of names
and numbers corresponding</p>
<p t="102010" d="2820">to a telephone
directory and you want</p>
<p t="104830" d="1500">to keep them in
sorted order so it's</p>
<p t="106330" d="5180">easy to search, mp3 organizers,
spreadsheets, et cetera.</p>
<p t="111510" d="3080">So there's lots of
obvious applications.</p>
<p t="114590" d="5040">There's also some
interesting problems</p>
<p t="119630" d="6270">that become easy once
items are sorted.</p>
<p t="133790" d="4380">One example of that
is finding a median.</p>
<p t="143860" d="3360">So let's say that you
have a bunch of items</p>
<p t="147220" d="8990">in an array a zero through
n and a zero through n</p>
<p t="156210" d="2440">contains n numbers and
they're not sorted.</p>
<p t="164850" d="4100">When you sort, you
turn this into b 0</p>
<p t="168950" d="3810">through n, where if
it's just numbers, then</p>
<p t="172760" d="2900">you may sort them in increasing
order or decreasing order.</p>
<p t="175660" d="3030">Let's just call it
increasing order for now.</p>
<p t="178690" d="2960">Or if they're records,
and they're not numbers,</p>
<p t="181650" d="2870">then you have to provide
a comparison function</p>
<p t="184520" d="3530">to determine which record is
smaller than another record.</p>
<p t="188050" d="1470">And that's another
input that you</p>
<p t="189520" d="3460">have to have in order
to do the sorting.</p>
<p t="192980" d="2330">So it doesn't really
matter what the items are</p>
<p t="195310" d="2270">as long as you have the
comparison function.</p>
<p t="197580" d="2350">Think of it as less
than or equal to.</p>
<p t="199930" d="3820">And if you have that and
it's straightforward,</p>
<p t="203750" d="3340">obviously, to check that 3
is less than 4, et cetera.</p>
<p t="207090" d="2550">But it may be a little
more complicated</p>
<p t="209640" d="3350">for more sophisticated
sorting applications.</p>
<p t="212990" d="3580">But the bottom line is that if
you have your algorithm that</p>
<p t="216570" d="2550">takes a comparison
function as an input,</p>
<p t="219120" d="3550">you're going to be able to,
after a certain amount of time,</p>
<p t="222670" d="2430">get B 0 n.</p>
<p t="225100" d="3580">Now if you wanted to find the
median of the set of numbers</p>
<p t="228680" d="3040">that were originally
in the array A,</p>
<p t="231720" d="4370">what would you do once you
have the sorted array B?</p>
<p t="236090" d="3034">AUDIENCE: Isn't there a more
efficient algorithm for median?</p>
<p t="239124" d="916">PROFESSOR: Absolutely.</p>
<p t="240040" d="8080">But this is sort of a side
effect of having a sorted list.</p>
<p t="248120" d="2120">If you happen to
have a sorted list,</p>
<p t="250240" d="4850">there's many ways
that you could imagine</p>
<p t="255090" d="1220">building up a sorted list.</p>
<p t="256310" d="3469">One way is you have something
that's completely unsorted</p>
<p t="259779" d="2841">and you run insertion
sort or merge sort.</p>
<p t="262620" d="2520">Another way would be to
maintain a sorted list as you're</p>
<p t="265140" d="2520">getting items put into the list.</p>
<p t="267660" d="1980">So if you happened
to have a sorted list</p>
<p t="269640" d="2960">and you need to have this
sorted list for some reason,</p>
<p t="272600" d="2840">the point I'm making here
is that finding the median</p>
<p t="275440" d="1700">is easy.</p>
<p t="277140" d="2290">And it's easy because
all you have to do</p>
<p t="279430" d="4375">is look at-- depending
on whether n is odd</p>
<p t="283805" d="3722">or even-- look at B of n over 2.</p>
<p t="287527" d="1833">That would give you the
median because you'd</p>
<p t="289360" d="4850">have a bunch of numbers
that are less than that</p>
<p t="294210" d="2620">and the equal set of numbers
that are greater than that,</p>
<p t="296830" d="2940">which is the
definition of median.</p>
<p t="299770" d="5260">So this is not necessarily the
best way, as you pointed out,</p>
<p t="305030" d="1370">of finding the median.</p>
<p t="306400" d="4920">But it's constant time if
you have a sorted list.</p>
<p t="311320" d="3330">That's the point
I wanted to make.</p>
<p t="314650" d="2070">There are other things
that you could do.</p>
<p t="316720" d="4060">And this came up
in Erik's lecture,</p>
<p t="320780" d="4790">which is the notion of
binary search-- finding</p>
<p t="325570" d="3080">an element in an array--
a specific element.</p>
<p t="328650" d="5440">You have a list of items--
again a 0 through n.</p>
<p t="334090" d="5510">And you're looking for a
specific number or item.</p>
<p t="343550" d="3090">You could, obviously,
scan the array,</p>
<p t="346640" d="3620">and that would take you
linear time to find this item.</p>
<p t="350260" d="2840">If the array happened
to be sorted,</p>
<p t="353100" d="5430">then you can find this
in logarithmic time</p>
<p t="358530" d="1765">using what's called
binary search.</p>
<p t="363600" d="2280">Let's say you're looking
for a specific item.</p>
<p t="365880" d="2400">Let's call it k.</p>
<p t="368280" d="2860">Binary search, roughly
speaking, would</p>
<p t="371140" d="9060">work like-- you go compare
k to, again, B of n over 2,</p>
<p t="380200" d="3580">and decide, given
that B is sorted,</p>
<p t="383780" d="4620">you get to look at
1/2 of the array.</p>
<p t="388400" d="4680">If B of n over 2 is not
exactly k, then-- well,</p>
<p t="393080" d="1310">if it's exactly k you're done.</p>
<p t="394390" d="2380">Otherwise, you look
at the left half.</p>
<p t="396770" d="2900">You do your divide
and conquer paradigm.</p>
<p t="399670" d="3150">And you can do this
in logarithmic time.</p>
<p t="402820" d="2880">So keep this in mind,
because binary search</p>
<p t="405700" d="2830">is going to come up
in today's lecture</p>
<p t="408530" d="2230">and again in other lectures.</p>
<p t="410760" d="2990">It's really a great
paradigm of divide</p>
<p t="413750" d="2270">and conquer--
probably the simplest.</p>
<p t="416020" d="1670">And it, essentially,
takes something</p>
<p t="417690" d="3350">that's linear--
a linear search--</p>
<p t="421040" d="2730">and turns it into
logarithmic search.</p>
<p t="423770" d="2770">So those are a
couple of problems</p>
<p t="426540" d="4410">that become easy if
you have a sorted list.</p>
<p t="430950" d="10320">And there's some not
so obvious applications</p>
<p t="441270" d="3880">of sorting-- for example,
data compression.</p>
<p t="445150" d="2640">If you wanted to
compress a file,</p>
<p t="447790" d="2740">one of the things that
you could do is to--</p>
<p t="450530" d="4800">and it's a set of items--
you could sort the items.</p>
<p t="455330" d="2540">And that automatically
finds duplicates.</p>
<p t="457870" d="5070">And you could say, if I have 100
items that are all identical,</p>
<p t="462940" d="4839">I'm going to compress the file
by representing the item once</p>
<p t="467779" d="1541">and, then, having
a number associated</p>
<p t="469320" d="3450">with the frequency of that
item-- similar to what</p>
<p t="472770" d="1670">document distance does.</p>
<p t="474440" d="3310">Document distance can
be viewed as a way</p>
<p t="477750" d="2020">of compressing
your initial input.</p>
<p t="479770" d="3470">Obviously, you lose the works of
Shakespeare or whatever it was.</p>
<p t="483240" d="3320">And it becomes a bunch
of words and frequencies.</p>
<p t="486560" d="6310">But it is something that
compresses the input</p>
<p t="492870" d="2720">and gives you a
different representation.</p>
<p t="495590" d="4805">And so people use sorting as a
subroutine in data compression.</p>
<p t="503190" d="4170">Computer graphics uses sorting.</p>
<p t="507360" d="3200">Most of the time,
when you render</p>
<p t="510560" d="2310">scenes in computer graphics,
you have many layers</p>
<p t="512870" d="1689">corresponding to the scenes.</p>
<p t="514559" d="3991">It turns out that,
in computer graphics,</p>
<p t="518550" d="1749">most of the time you're
actually rendering</p>
<p t="520299" d="4111">front to back because,
when you have a big opaque</p>
<p t="524410" d="4477">object in front, you want
to render that first,</p>
<p t="528887" d="2083">so you don't have to worry
about everything that's</p>
<p t="530970" d="3090">occluded by this
big opaque object.</p>
<p t="534060" d="2530">And that makes things
more efficient.</p>
<p t="536590" d="2110">And so you keep things
sorted front to back,</p>
<p t="538700" d="2460">most of the time, in
computer graphics rendering.</p>
<p t="541160" d="2700">But some of the time, if you're
worried about transparency,</p>
<p t="543860" d="1800">you have to render
things back to front.</p>
<p t="545660" d="2730">So typically, you
have sorted lists</p>
<p t="548390" d="3160">corresponding to the different
objects in both orders--</p>
<p t="551550" d="2180">both increasing order
and decreasing order.</p>
<p t="553730" d="1500">And you're maintaining that.</p>
<p t="555230" d="3960">So sorting is a real
important subroutine</p>
<p t="559190" d="3900">in pretty much any sophisticated
application you look at.</p>
<p t="563090" d="3690">So it's worthwhile to look
at the variety of sorting</p>
<p t="566780" d="1570">algorithms that are out there.</p>
<p t="568350" d="2082">And we're going to do
some simple ones, today.</p>
<p t="570432" d="1458">But if you go and
look at Wikipedia</p>
<p t="571890" d="3380">and do a Google search,
there's all sorts</p>
<p t="575270" d="2760">of sorts like cocktail
sort, and bitonic sort,</p>
<p t="578030" d="3870">and what have you.</p>
<p t="581900" d="4000">And there's reasons why each of
these sorting algorithms exist.</p>
<p t="585900" d="3930">Because in specific
cases, they end up</p>
<p t="589830" d="3225">winning on types of inputs
or types of problems.</p>
<p t="595660" d="3810">So let's take a look at our
first sorting algorithm.</p>
<p t="599470" d="4170">I'm not going to write code
but it will be in the notes.</p>
<p t="603640" d="5220">And it is in your document
distance Python files.</p>
<p t="608860" d="1910">But I'll just give
you pseudocode here</p>
<p t="610770" d="2980">and walk through what
insertion sort looks like</p>
<p t="613750" d="3710">because the purpose
of describing</p>
<p t="617460" d="3296">this algorithm to you is
to analyze its complexity.</p>
<p t="620756" d="1374">We need to do some
counting here,</p>
<p t="622130" d="3100">with respect to this
algorithm, to figure out</p>
<p t="625230" d="3380">how fast it's going to run
in and what the worst case</p>
<p t="628610" d="1670">complexity is.</p>
<p t="630280" d="2305">So what is insertion sort?</p>
<p t="632585" d="9195">For i equals 1, 2, through n,
given an input to be sorted,</p>
<p t="641780" d="4820">what we're going to do is
we're going to insert A of i</p>
<p t="646600" d="1870">in the right position.</p>
<p t="648470" d="2700">And we're going
to assume that we</p>
<p t="651170" d="4050">are sort of midway through
the sorting process, where</p>
<p t="655220" d="5700">we have sorted A 0
through i minus 1.</p>
<p t="660920" d="3420">And we're going to
expand this to this array</p>
<p t="664340" d="3250">to have i plus 1 elements.</p>
<p t="667590" d="2060">And A of i is going
to get inserted</p>
<p t="669650" d="3180">into the correct position.</p>
<p t="672830" d="10810">And we're going to do
this by pairwise swaps</p>
<p t="683640" d="9090">down to the correct position
for the number that is initially</p>
<p t="692730" d="760">in A of i.</p>
<p t="696050" d="6360">So let's go through
an example of this.</p>
<p t="702410" d="2430">We're going to sort
in increasing order.</p>
<p t="704840" d="1045">Just have six numbers.</p>
<p t="710430" d="4375">And initially, we
have 5, 2, 4, 6, 1, 3.</p>
<p t="714805" d="1625">And we're going to
take a look at this.</p>
<p t="716430" d="4120">And you start with the index
1, or the second element,</p>
<p t="720550" d="3070">because the very first
element-- it's a single element</p>
<p t="723620" d="2430">and it's already
sorted by definition.</p>
<p t="726050" d="1880">But you start from here.</p>
<p t="727930" d="2960">And this is what
we call our key.</p>
<p t="730890" d="4360">And that's essentially a pointer
to where we're at, right now.</p>
<p t="735250" d="1770">And the key keeps
moving to the right</p>
<p t="737020" d="2987">as we go through the different
steps of the algorithm.</p>
<p t="740007" d="1583">And so what you do
is you look at this</p>
<p t="741590" d="3240">and you have-- this is A of i.</p>
<p t="744830" d="1200">That's your key.</p>
<p t="746030" d="4040">And you have A of
0 to 0, which is 5.</p>
<p t="750070" d="4190">And since we want to
sort in increasing order,</p>
<p t="754260" d="1680">this is not sorted.</p>
<p t="755940" d="1780">And so we do a swap.</p>
<p t="757720" d="4680">So what this would do in
this step is to do a swap.</p>
<p t="762400" d="9430">And we would go obtain
2, 5, 4, 6, 1, 3.</p>
<p t="771830" d="3250">So all that's happened here,
in this step-- in the very</p>
<p t="775080" d="2280">first step where the key
is in the second position--</p>
<p t="777360" d="2660">is one swap happened.</p>
<p t="780020" d="3320">Now, your key is
here, at item 4.</p>
<p t="783340" d="2640">Again, you need to put
4 into the right spot.</p>
<p t="785980" d="2690">And so you do pairwise swaps.</p>
<p t="788670" d="2610">And in this case, you
have to do one swap.</p>
<p t="791280" d="1470">And you get 2, 4, 5.</p>
<p t="792750" d="2900">And you're done
with this iteration.</p>
<p t="795650" d="12200">So what happens here is
you have 2, 4, 5, 6, 1, 3.</p>
<p t="807850" d="5160">And now, the key
is over here, at 6.</p>
<p t="813010" d="4850">Now, at this point,
things are kind of easy,</p>
<p t="817860" d="3320">in the sense that you look
at it and you say, well, I</p>
<p t="821180" d="2300">know this part is
already started.</p>
<p t="823480" d="1490">6 is greater than 5.</p>
<p t="824970" d="2030">So you have to do nothing.</p>
<p t="827000" d="4530">So there's no swaps that
happen in this step.</p>
<p t="831530" d="4910">So all that happens
here is you're</p>
<p t="836440" d="5840">going to move the key to
one step to the right.</p>
<p t="842280" d="4090">So you have 2, 4, 5, 6, 1, 3.</p>
<p t="846370" d="3900">And your key is now at 1.</p>
<p t="850270" d="1640">Here, you have to do more work.</p>
<p t="851910" d="4860">Now, you see one aspect of the
complexity of this algorithm--</p>
<p t="856770" d="2700">given that you're doing
pairwise swaps-- the way</p>
<p t="859470" d="3950">this algorithm was defined, in
pseudocode, out there, was I'm</p>
<p t="863420" d="4340">going to use pairwise swaps
to find the correct position.</p>
<p t="867760" d="1880">So what you're going
to do is you're</p>
<p t="869640" d="4440">going to have to
swap first 1 and 6.</p>
<p t="874080" d="2230">And then you'll
swap-- 1 is over here.</p>
<p t="876310" d="3660">So you'll swap this
position and that position.</p>
<p t="879970" d="4610">And then you'll
swap-- essentially,</p>
<p t="884580" d="5330">do 4 swaps to get to
the point where you have</p>
<p t="889910" d="3060">1, 2, 4, 5, 6, 3.</p>
<p t="892970" d="3680">So this is the result.</p>
<p t="899190" d="4580">1, 2, 4, 5, 6, 3.</p>
<p t="903770" d="2590">And the important thing
to understand, here,</p>
<p t="906360" d="2690">is that you've done
four swaps to get 1</p>
<p t="909050" d="1110">to the correct position.</p>
<p t="910160" d="2320">Now, you could imagine a
different data structure</p>
<p t="912480" d="2990">where you move this over
there and you shift them</p>
<p t="915470" d="1460">all to the right.</p>
<p t="916930" d="3300">But in fact, that shifting
of these four elements</p>
<p t="920230" d="3400">is going to be computed
in our model as four</p>
<p t="923630" d="2614">operations, or
four steps, anyway.</p>
<p t="926244" d="1666">So there's no getting
away from the fact</p>
<p t="927910" d="2750">that you have to do
four things here.</p>
<p t="930660" d="6170">And the way the code that
we have for insertion sort</p>
<p t="936830" d="2570">does this is by
using pairwise swaps.</p>
<p t="939400" d="2070">So we're almost done.</p>
<p t="941470" d="8020">Now, we have the key at 3.</p>
<p t="949490" d="3420">And now, 3 needs to get put
into the correct position.</p>
<p t="952910" d="2440">And so you've got
to do a few swaps.</p>
<p t="955350" d="2970">This is the last step.</p>
<p t="958320" d="5260">And what happens here is 3 is
going to get swapped with 6.</p>
<p t="963580" d="2940">And then 3 needs to
get swapped with 5.</p>
<p t="966520" d="3250">And then 3 needs to
get swapped with 4.</p>
<p t="969770" d="3215">And then, since 3 is
greater than 2, you're done.</p>
<p t="972985" d="3340">So you have 1, 2, 3, 4, 5, 6.</p>
<p t="978880" d="2300">And that's it.</p>
<p t="981180" d="1640">So, analysis.</p>
<p t="985380" d="1250">How many steps do I have?</p>
<p t="990670" d="1480">AUDIENCE: n squared?</p>
<p t="992150" d="4160">PROFESSOR: No, how
many steps do I have?</p>
<p t="996310" d="3810">I guess that wasn't
a good question.</p>
<p t="1000120" d="3810">If I think of a step as
being a movement of the key,</p>
<p t="1003930" d="2285">how many steps do I have?</p>
<p t="1006215" d="3715">I have theta n steps.</p>
<p t="1009930" d="6640">And in this case, you can
think of it as n minus 1 steps,</p>
<p t="1016570" d="1460">since you started with 2.</p>
<p t="1018030" d="5870">But let's just call
it theta n steps,</p>
<p t="1023900" d="2880">in terms of key positions.</p>
<p t="1030060" d="1090">And you're right.</p>
<p t="1031150" d="4199">It is n square because,
at any given step,</p>
<p t="1035349" d="4381">it's quite possible that
I have to do theta n work.</p>
<p t="1039730" d="2670">And one example is
this one, right here,</p>
<p t="1042400" d="2760">where I had to do four swaps.</p>
<p t="1045160" d="2439">And in general, you can
construct a scenario</p>
<p t="1047599" d="3871">where, towards the
end of the algorithm,</p>
<p t="1051470" d="2650">you'd have to do theta n work.</p>
<p t="1054120" d="3440">But if you had a list
that was reverse sorted.</p>
<p t="1057560" d="3400">You would, essentially,
have to do, on an average n</p>
<p t="1060960" d="2890">by two swaps as you go
through each of the steps.</p>
<p t="1063850" d="1450">And that's theta n.</p>
<p t="1065300" d="6850">So each step is theta n swaps.</p>
<p t="1075930" d="2810">And when I say
swaps, I could also</p>
<p t="1078740" d="7905">say each step is theta
n compares and swaps.</p>
<p t="1086645" d="1375">And this is going
to be important</p>
<p t="1088020" d="2410">because I'm going to ask
you an interesting question</p>
<p t="1090430" d="1270">in a minute.</p>
<p t="1091700" d="2140">But let me summarize.</p>
<p t="1093840" d="2630">What I have here is a
theta n squared algorithm.</p>
<p t="1096470" d="1500">The reason this is
a theta n squared</p>
<p t="1097970" d="4790">algorithm is because
I have theta n steps</p>
<p t="1102760" d="4100">and each step is theta n.</p>
<p t="1106860" d="2280">When I'm counting,
what am I counting</p>
<p t="1109140" d="1590">it terms of operations?</p>
<p t="1110730" d="2780">The assumption here--
unspoken assumption--</p>
<p t="1113510" d="3300">has been that an operation
is a compare and a swap</p>
<p t="1116810" d="2730">and they're, essentially,
equal in cost.</p>
<p t="1119540" d="2310">And in most computers,
that's true.</p>
<p t="1121850" d="3360">You have a single
instruction and, say, the x86</p>
<p t="1125210" d="2490">or the MIPS architecture
that can do a compare,</p>
<p t="1127700" d="2960">and the same thing for
swapping registers.</p>
<p t="1130660" d="1980">So perfectly
reasonably assumption</p>
<p t="1132640" d="3840">that compares and
swaps for numbers</p>
<p t="1136480" d="1930">have exactly the same cost.</p>
<p t="1138410" d="3490">But if you had a record and
you were comparing records,</p>
<p t="1141900" d="3800">and the comparison function that
you used for the records was</p>
<p t="1145700" d="3120">in itself a method
call or a subroutine,</p>
<p t="1148820" d="2470">it's quite possible
that all you're doing</p>
<p t="1151290" d="4310">is swapping pointers or
references to do the swap,</p>
<p t="1155600" d="2385">but the comparison could be
substantially more expensive.</p>
<p t="1162870" d="2050">Most of the time-- and
we'll differentiate</p>
<p t="1164920" d="2230">if it becomes
necessary-- we're going</p>
<p t="1167150" d="2410">to be counting comparisons
in the sorting algorithms</p>
<p t="1169560" d="1670">that we'll be putting out.</p>
<p t="1171230" d="4900">And we'll be assuming that
either comparison swaps are</p>
<p t="1176130" d="4910">roughly the same or
that compares are--</p>
<p t="1181040" d="3530">and we'll say which one,
of course-- that compares</p>
<p t="1184570" d="3260">are substantially more
expensive than swaps.</p>
<p t="1187830" d="4440">So if you had either of those
cases for insertion sort,</p>
<p t="1192270" d="1956">you have a theta n
squared algorithm.</p>
<p t="1194226" d="1374">You have theta n
squared compares</p>
<p t="1195600" d="2600">and theta n squared swaps.</p>
<p t="1198200" d="2580">Now, here's a question.</p>
<p t="1200780" d="10399">Let's say that compares are
more expensive than swaps.</p>
<p t="1211179" d="1541">And so, I'm concerned
about the theta</p>
<p t="1212720" d="2030">n squared comparison cost.</p>
<p t="1217270" d="3610">I'm not as concerned, because of
the constant factors involved,</p>
<p t="1220880" d="1830">with the theta n
squared swap cost.</p>
<p t="1225410" d="3320">This is a question question.</p>
<p t="1228730" d="4860">What's a simple fix-- change
to this algorithm that</p>
<p t="1233590" d="3670">would give me a better
complexity in the case</p>
<p t="1237260" d="2640">where compares are
more expensive,</p>
<p t="1239900" d="3400">or I'm only looking at the
complexity of compares.</p>
<p t="1243300" d="3690">So the theta
whatever of compares.</p>
<p t="1246990" d="960">Anyone?</p>
<p t="1247950" d="711">Yeah, back there.</p>
<p t="1248661" d="875">AUDIENCE: [INAUDIBLE]</p>
<p t="1256356" d="1874">PROFESSOR: You could
compare with the middle.</p>
<p t="1258230" d="791">What did I call it?</p>
<p t="1261910" d="1210">I called it something.</p>
<p t="1263120" d="3041">What you just said, I
called it something.</p>
<p t="1266161" d="999">AUDIENCE: Binary search.</p>
<p t="1267160" d="580">PROFESSOR: Binary search.</p>
<p t="1267740" d="570">That's right.</p>
<p t="1268310" d="1970">Two cushions for this one.</p>
<p t="1270280" d="1941">So you pick them
up after lecture.</p>
<p t="1272221" d="999">So you're exactly right.</p>
<p t="1273220" d="708">You got it right.</p>
<p t="1273928" d="4232">I called it binary
search, up here.</p>
<p t="1278160" d="3460">And so you can
take insertion sort</p>
<p t="1281620" d="3180">and you can sort of trivially
turn it into a theta n log n</p>
<p t="1284800" d="2400">algorithm if we
are talking about n</p>
<p t="1287200" d="2710">being the number of compares.</p>
<p t="1289910" d="2515">And all you have to do
to do that is to say,</p>
<p t="1292425" d="1855">you know what, I'm
going to replace</p>
<p t="1294280" d="3670">this with binary search.</p>
<p t="1297950" d="4770">And you can do that-- and
that was the key observation--</p>
<p t="1302720" d="5270">because A of 0 through i
minus 1 is already sorted.</p>
<p t="1307990" d="3919">And so you can do binary search
on that part of the array.</p>
<p t="1311909" d="1291">So let me just write that down.</p>
<p t="1316750" d="7250">Do a binary search on A
of 0 through i minus 1,</p>
<p t="1324000" d="1095">which is already sorted.</p>
<p t="1330540" d="6240">And essentially, you can think
of it as theta log i time,</p>
<p t="1336780" d="1290">and for each of those steps.</p>
<p t="1338070" d="9181">And so then you get your
theta n log n theta n log</p>
<p t="1347251" d="3159">n in terms of compares.</p>
<p t="1350410" d="7530">Does this help the swaps
for an array data structure?</p>
<p t="1357940" d="3340">No, because binary search
will require insertion</p>
<p t="1361280" d="3390">into A of 0 though i minus 1.</p>
<p t="1364670" d="1210">So here's the problem.</p>
<p t="1365880" d="4550">Why don't we have a full-fledged
theta n log n algorithm,</p>
<p t="1370430" d="3510">regardless of the cost
of compares or swaps?</p>
<p t="1373940" d="1530">We don't quite have that.</p>
<p t="1375470" d="7480">We don't quite have that because
we need to insert our A of i</p>
<p t="1382950" d="4900">into the right position into
A of 0 through i minus 1.</p>
<p t="1387850" d="1940">You do that if you have
an array structure,</p>
<p t="1389790" d="1208">it might get into the middle.</p>
<p t="1390998" d="2339">And you have to shift
things over to the right.</p>
<p t="1393337" d="1833">And when you shift
things over to the right,</p>
<p t="1395170" d="1920">in the worst case, you may
be shifting a lot of things</p>
<p t="1397090" d="890">over to the right.</p>
<p t="1397980" d="2650">And that gets back to worst
case complexity of theta n.</p>
<p t="1403200" d="3800">So a binary search
in insertion sort</p>
<p t="1407000" d="2197">gives you theta n
log n for compares.</p>
<p t="1409197" d="1708">But it's still theta
n squared for swaps.</p>
<p t="1415000" d="1805">So as you can see,
there's many varieties</p>
<p t="1416805" d="965">of sorting algorithms.</p>
<p t="1417770" d="2080">We just looked at
a couple of them.</p>
<p t="1419850" d="3160">And they were both
insertion sort.</p>
<p t="1423010" d="2030">The second one
that I just put up</p>
<p t="1425040" d="3860">is, I guess, technically
called binary insertion sort</p>
<p t="1428900" d="1810">because it does binary search.</p>
<p t="1430710" d="2290">And the vanilla
insertion sort is</p>
<p t="1433000" d="3676">the one that you have the code
for in the doc dis program,</p>
<p t="1436676" d="2724">or at least one of
the doc dis files.</p>
<p t="1439400" d="5220">So let's move on and talk
about a different algorithm.</p>
<p t="1444620" d="2210">So what we'd like to
do, now-- this class</p>
<p t="1446830" d="2290">is about constant improvement.</p>
<p t="1449120" d="2360">We're never happy.</p>
<p t="1451480" d="2890">We always want to do
a little bit better.</p>
<p t="1454370" d="2494">And eventually, once
we run out of room</p>
<p t="1456864" d="1416">from an asymptotic
standpoint, you</p>
<p t="1458280" d="2083">take these other classes
where you try and improve</p>
<p t="1460363" d="4017">constant factors and
get 10%, and 5%, and 1%,</p>
<p t="1464380" d="1180">and so on, and so forth.</p>
<p t="1465560" d="5640">But we'll stick to improving
asymptotic complexity.</p>
<p t="1471200" d="2990">And we're not quite happy
with binary insertion sort</p>
<p t="1474190" d="2860">because, in the case of numbers,
our binary insertion sort</p>
<p t="1477050" d="3659">has theta n squared complexity,
if you look at swaps.</p>
<p t="1480709" d="2333">So we'd like to go find an
algorithm that is theta n log</p>
<p t="1483042" d="1768">n.</p>
<p t="1484810" d="4790">And I guess, eventually,
we'll have to stop.</p>
<p t="1489600" d="1660">But Erik will take care of that.</p>
<p t="1493900" d="1070">There's a reason to stop.</p>
<p t="1494970" d="3650">It's when you can prove that
you can't do any better.</p>
<p t="1498620" d="2590">And so we'll get to
that, eventually.</p>
<p t="1501210" d="3475">So merge sort is also something
that you've probably seen.</p>
<p t="1507277" d="1458">But there probably
will be a couple</p>
<p t="1508735" d="3705">of subtleties that come out as
I describe this algorithm that,</p>
<p t="1512440" d="2900">hopefully, will be interesting
to those of you who already</p>
<p t="1515340" d="1470">know merge sort.</p>
<p t="1516810" d="4220">And for those of you who don't,
it's a very pretty algorithm.</p>
<p t="1521030" d="5900">It's a standard recursion
algorithm-- recursive</p>
<p t="1526930" d="3690">algorithm-- similar
to a binary search.</p>
<p t="1530620" d="4160">What we do, here, is we have
an array, A. We split it</p>
<p t="1534780" d="7315">into two parts, L and R.
And essentially, we kind of</p>
<p t="1542095" d="1855">do no work, really.</p>
<p t="1543950" d="5864">In terms of the L and R in
the sense that we just call,</p>
<p t="1549814" d="1666">we keep splitting,
splitting, splitting.</p>
<p t="1551480" d="2540">And all the work is
done down at the bottom</p>
<p t="1554020" d="3550">in this routine called
merge, where we are merging</p>
<p t="1557570" d="2540">a pair of elements
at the leaves.</p>
<p t="1560110" d="4380">And then, we merge two
pairs and get four elements.</p>
<p t="1564490" d="4140">And then we merge four tuples
of elements, et cetera,</p>
<p t="1568630" d="1450">and go all the way up.</p>
<p t="1570080" d="8910">So while I'm just saying L
terms into L prime, out here,</p>
<p t="1578990" d="2000">there's no real
explicit code that you</p>
<p t="1580990" d="2880">can see that turns
L into L prime.</p>
<p t="1583870" d="1760">It happens really later.</p>
<p t="1585630" d="1560">There's no real
sorting code, here.</p>
<p t="1587190" d="1600">It happens in the merge routine.</p>
<p t="1588790" d="1859">And you'll see
that quite clearly</p>
<p t="1590649" d="1291">when we run through an example.</p>
<p t="1594960" d="6540">So you have L and R turn
into L prime and R prime.</p>
<p t="1601500" d="10810">And what we end up getting
is a sorted array, A.</p>
<p t="1612310" d="6590">And we have what's called
a merge routine that</p>
<p t="1618900" d="2210">takes L prime and R
prime and merges them</p>
<p t="1621110" d="1290">into the sorted array.</p>
<p t="1622400" d="6870">So at the top level, what
you see is split into two,</p>
<p t="1629270" d="4010">and do a merge, and get
to the sorted array.</p>
<p t="1633280" d="3400">The input is of size n.</p>
<p t="1636680" d="8010">You have two arrays
of size n over 2.</p>
<p t="1644690" d="8520">These are two sorted
arrays of size n over 2.</p>
<p t="1653210" d="6270">And then, finally, you have
a sorted array of size n.</p>
<p t="1662116" d="2124">So if you want to follow
the recursive of execution</p>
<p t="1664240" d="5630">of this in a small
example, then you'll</p>
<p t="1669870" d="3920">be able to see how this works.</p>
<p t="1673790" d="2330">And we'll do a fairly
straightforward example</p>
<p t="1676120" d="2080">with 8 elements.</p>
<p t="1678200" d="4980">So at the top level--
before we get there, merge</p>
<p t="1683180" d="5460">is going to assume that
you have two sorted arrays,</p>
<p t="1688640" d="3060">and merge them together.</p>
<p t="1691700" d="4260">That's the invariant in merge
sort, or for the merge routine.</p>
<p t="1695960" d="3610">It assumes the inputs are
sorted-- L and R. Actually</p>
<p t="1699570" d="3230">I should say, L
prime and R prime.</p>
<p t="1702800" d="4824">So let's say you have
20, 13, 7, and 2.</p>
<p t="1707624" d="3696">You have 12, 11, 9, and 1.</p>
<p t="1711320" d="2080">And this could be L prime.</p>
<p t="1713400" d="3440">And this could be R prime.</p>
<p t="1716840" d="2810">What you have is what we
call a two finger algorithm.</p>
<p t="1719650" d="2730">And so you've got two
fingers and each of them</p>
<p t="1722380" d="1782">point to something.</p>
<p t="1724162" d="1708">And in this case, one
of them is pointing</p>
<p t="1725870" d="3320">to L. My left finger
is pointing to L prime,</p>
<p t="1729190" d="1610">or some element L prime.</p>
<p t="1730800" d="3050">My right finger is pointing
to some element in R prime.</p>
<p t="1733850" d="2970">And I'm going to
compare the two elements</p>
<p t="1736820" d="1920">that my fingers are pointing to.</p>
<p t="1738740" d="3430">And I'm going to
choose, in this case,</p>
<p t="1742170" d="1670">the smaller of those elements.</p>
<p t="1743840" d="3950">And I'm going to put them
into the sorted array.</p>
<p t="1747790" d="3180">So start out here.</p>
<p t="1750970" d="1510">Look at that and that.</p>
<p t="1752480" d="1786">And I compared 2 and 1.</p>
<p t="1754266" d="874">And which is smaller?</p>
<p t="1755140" d="1170">1 is smaller.</p>
<p t="1756310" d="2820">So I'm going to write 1 down.</p>
<p t="1759130" d="4590">This is a two finger
algo for merge.</p>
<p t="1763720" d="1160">And I put 1 down.</p>
<p t="1764880" d="2500">When I put 1 down, I
had to cross out 1.</p>
<p t="1767380" d="2015">So effectively, what
happens is-- let</p>
<p t="1769395" d="2065">me just circle that
instead of crossing it out.</p>
<p t="1771460" d="3990">And my finger moves up to 9.</p>
<p t="1775450" d="2660">So now I'm pointing at 2 and 9.</p>
<p t="1778110" d="1970">And I repeat this step.</p>
<p t="1780080" d="1790">So now, in this
case, 2 is smaller.</p>
<p t="1781870" d="2170">So I'm going to go
ahead and write 2 down.</p>
<p t="1784040" d="5380">And I can cross out 2 and
move my finger up to 7.</p>
<p t="1789420" d="1420">And so that's it.</p>
<p t="1790840" d="3170">I won't bore you with
the rest of the steps.</p>
<p t="1794010" d="2104">It's essentially walking up.</p>
<p t="1796114" d="1666">You have a couple of
pointers and you're</p>
<p t="1797780" d="2140">walking up these two arrays.</p>
<p t="1799920" d="7310">And you're writing down 1,
2, 7, 9, 11, 12, 13, 20.</p>
<p t="1807230" d="1500">And that's your merge routine.</p>
<p t="1808730" d="3600">And all of the work, really,
is done in the merge routine</p>
<p t="1812330" d="3130">because, other than
that, the body is simply</p>
<p t="1815460" d="1160">a recursive call.</p>
<p t="1816620" d="1800">You have to, obviously,
split the array.</p>
<p t="1818420" d="1690">But that's fairly
straightforward.</p>
<p t="1820110" d="4490">If you have an array, A 0
through n-- and depending on</p>
<p t="1824600" d="3700">whether n is odd
or even-- you could</p>
<p t="1828300" d="10230">imagine that you set L
to be A 0 n by 2 minus 1,</p>
<p t="1838530" d="2890">and R similarly.</p>
<p t="1841420" d="2666">And so you just split it
halfway in the middle.</p>
<p t="1844086" d="1624">I'll talk about that
a little bit more.</p>
<p t="1845710" d="1624">There's a subtlety
associated with that</p>
<p t="1847334" d="3866">that we'll get to
in a few minutes.</p>
<p t="1851200" d="4080">But to finish up in terms of
the computation of merge sort.</p>
<p t="1855280" d="830">This is it.</p>
<p t="1856110" d="4717">The merge routine is doing
most, if not all, of the work.</p>
<p t="1860827" d="1583">And this two finger
algorithm is going</p>
<p t="1862410" d="2220">to be able to take
two sorted arrays</p>
<p t="1864630" d="4920">and put them into a
single sorted array</p>
<p t="1869550" d="3600">by interspersing, or
interleaving, these elements.</p>
<p t="1873150" d="1850">And what's the
complexity of merge</p>
<p t="1875000" d="3710">if I have two arrays
of size n over 2, here?</p>
<p t="1878710" d="3100">What do I have?</p>
<p t="1881810" d="780">AUDIENCE: n.</p>
<p t="1882590" d="1141">PROFESSOR: n.</p>
<p t="1883731" d="1249">We'll give you a cushion, too.</p>
<p t="1888050" d="1115">theta n complexity.</p>
<p t="1895470" d="820">So far so good.</p>
<p t="1898830" d="2810">I know you know the
answer as to what</p>
<p t="1901640" d="1910">the complexity of merge sort is.</p>
<p t="1903550" d="1630">But I'm guessing
that most of you</p>
<p t="1905180" d="2720">won't be able to prove it to me
because I'm kind of a hard guy</p>
<p t="1907900" d="3020">to prove something to.</p>
<p t="1910920" d="2120">And I could always say,
no, I don't believe you</p>
<p t="1913040" d="916">or I don't understand.</p>
<p t="1917960" d="2920">The complexity-- and you've
said this before, in class,</p>
<p t="1920880" d="1700">and I think Erik's
mentioned it--</p>
<p t="1922580" d="5790">the overall complexity of this
algorithm is theta n log n</p>
<p t="1928370" d="1440">And where does that come from?</p>
<p t="1929810" d="1980">How do you prove that?</p>
<p t="1931790" d="5050">And so what we'll do, now,
is take a look at merge sort.</p>
<p t="1936840" d="2230">And we'll look at
the recursion tree.</p>
<p t="1939070" d="1625">And we'll try and--
there are many ways</p>
<p t="1940695" d="2675">of proving that merge
sort is theta n log n.</p>
<p t="1943370" d="2490">The way we're
going to do this is</p>
<p t="1945860" d="2780">what's called proof by picture.</p>
<p t="1948640" d="3650">And it's not an established
proof technique,</p>
<p t="1952290" d="2730">but it's something
that is very helpful</p>
<p t="1955020" d="3080">to get an intuition
behind the proof</p>
<p t="1958100" d="2341">and why the result is true.</p>
<p t="1960441" d="1499">And you can always
take that and you</p>
<p t="1961940" d="5090">can formalize it and
make this something</p>
<p t="1967030" d="2650">that everyone believes.</p>
<p t="1969680" d="3280">And we'll also look at
substitution, possibly</p>
<p t="1972960" d="3350">in section tomorrow,
for recurrence solving.</p>
<p t="1976310" d="4230">So where we're right now is that
we have a divide and conquer</p>
<p t="1980540" d="7170">algorithm that has a merge
step that is theta n.</p>
<p t="1987710" d="4830">And so, if I just look at this
structure that I have here,</p>
<p t="1992540" d="3610">I can write a recurrence
for merge sort</p>
<p t="1996150" d="1816">that looks like this.</p>
<p t="1997966" d="4754">So when I say
complexity, I can say</p>
<p t="2002720" d="3510">T of n, which is the
work done for n items,</p>
<p t="2006230" d="2680">is going to be some
constant time in order</p>
<p t="2008910" d="3030">to divide the array.</p>
<p t="2011940" d="2260">So this could be the
part corresponding</p>
<p t="2014200" d="2160">to dividing the array.</p>
<p t="2016360" d="4000">And there's going to be two
problems of size n over 2.</p>
<p t="2020360" d="2450">And so I have 2 T of n over 2.</p>
<p t="2022810" d="1900">And this is the recursive part.</p>
<p t="2028650" d="5310">And I'm going to have c times
n, which is the merge part.</p>
<p t="2033960" d="4950">And that's some constant times
n, which is what we have,</p>
<p t="2038910" d="2980">here, with respect to
the theta n complexity.</p>
<p t="2041890" d="3090">So you have a recurrence like
this and I know some of you</p>
<p t="2044980" d="2170">have seen recurrences in 6.042.</p>
<p t="2047150" d="2089">And you know how to solve this.</p>
<p t="2049239" d="5230">What I'd like to do is show you
this recursion tree expansion</p>
<p t="2054469" d="3520">that, not only tells you how
to solve this occurrence,</p>
<p t="2057989" d="5113">but also gives you a means
of solving recurrences where,</p>
<p t="2063102" d="2458">instead of having c of n, you
have something else out here.</p>
<p t="2065560" d="2230">You have f of n, which
is a different function</p>
<p t="2067790" d="1490">from the linear function.</p>
<p t="2069280" d="4470">And this recursion
tree is, in my mind,</p>
<p t="2073750" d="4900">the simplest way of
arguing the theta n log n</p>
<p t="2078650" d="2450">complexity of merge sort.</p>
<p t="2081100" d="3239">So what I want to do is
expand this recurrence out.</p>
<p t="2084339" d="1166">And let's do that over here.</p>
<p t="2106830" d="4120">So I have c of n on top.</p>
<p t="2110950" d="4900">I'm going to ignore this
constant factor because c of n</p>
<p t="2115850" d="700">dominates.</p>
<p t="2116550" d="1530">So I'll just start with c of n.</p>
<p t="2118080" d="5370">I want to break things
up, as I do the recursion.</p>
<p t="2123450" d="3510">So when I go c of n, at
the top level-- that's</p>
<p t="2126960" d="2790">the work I have to do at
the merge, at the top level.</p>
<p t="2129750" d="3360">And then when I go down to two
smaller problems, each of them</p>
<p t="2133110" d="1370">is size n over 2.</p>
<p t="2134480" d="3960">So I do c times n
divided by 2 [INAUDIBLE].</p>
<p t="2138440" d="3177">So this is just a constant c.</p>
<p t="2141617" d="1583">I didn't want to
write thetas up here.</p>
<p t="2143200" d="1240">You could.</p>
<p t="2144440" d="2320">And I'll say a little bit
more about that later.</p>
<p t="2146760" d="2420">But think of this cn as
representing the theta n</p>
<p t="2149180" d="1080">complexity.</p>
<p t="2150260" d="2530">And c is this constant.</p>
<p t="2152790" d="5170">So c times n, here. c
times n over 2, here.</p>
<p t="2157960" d="3800">And then when I keep going,
I have c times n over 4,</p>
<p t="2161760" d="7150">c times n over 4, et cetera,
and so on, and so forth.</p>
<p t="2168910" d="1740">And when I come down
all the way here,</p>
<p t="2170650" d="6020">n is eventually going to become
1-- or essentially a constant--</p>
<p t="2176670" d="4120">and I'm going to have
a bunch of c's here.</p>
<p t="2180790" d="6260">So here's another question,
that I'd like you to answer.</p>
<p t="2187050" d="4160">Someone tell me what the number
of levels in this tree are,</p>
<p t="2191210" d="2850">precisely, and the number
of leaves in this tree are,</p>
<p t="2194060" d="1510">precisely.</p>
<p t="2195570" d="2491">AUDIENCE: The number of
levels is log n plus 1.</p>
<p t="2198061" d="999">PROFESSOR: Log n plus 1.</p>
<p t="2199060" d="2109">Log to the base 2 plus 1.</p>
<p t="2201169" d="1041">And the number of leaves?</p>
<p t="2208430" d="2150">You raised your hand
back there, first.</p>
<p t="2210580" d="850">Number of leaves.</p>
<p t="2211430" d="1450">AUDIENCE: I think n.</p>
<p t="2212880" d="1250">PROFESSOR: Yeah, you're right.</p>
<p t="2214130" d="2080">You think right.</p>
<p t="2216210" d="6310">So 1 plus log n and n leaves.</p>
<p t="2222520" d="3350">When n becomes 1, how
many of them do you have?</p>
<p t="2225870" d="3600">You're down to a single element,
which is, by definition,</p>
<p t="2229470" d="1110">sorted.</p>
<p t="2230580" d="3150">And you have n leaves.</p>
<p t="2233730" d="3290">So now let's add up the work.</p>
<p t="2237020" d="3210">I really like this
picture because it's just</p>
<p t="2240230" d="3220">so intuitive in terms
of getting us the result</p>
<p t="2243450" d="1640">that we're looking for.</p>
<p t="2245090" d="4990">So you add up the work in each
of the levels of this tree.</p>
<p t="2250080" d="2110">So the top level is cn.</p>
<p t="2252190" d="7600">The second level is cn because
I added 1/2 and 1/2, cn, cn.</p>
<p t="2259790" d="960">Wow.</p>
<p t="2260750" d="2260">What symmetry.</p>
<p t="2263010" d="7490">So you're doing the same
amount of work modulo</p>
<p t="2270500" d="3550">the constant factors,
here, with what's</p>
<p t="2274050" d="2230">going on with the c1,
which we've ignored,</p>
<p t="2276280" d="3590">but roughly the same amount
of work in each of the levels.</p>
<p t="2279870" d="2700">And now, you know how
many levels there are.</p>
<p t="2282570" d="2280">It's 1 plus log n.</p>
<p t="2284850" d="7080">So if you want to write
an equation for T of n,</p>
<p t="2291930" d="11100">it's 1 plus log n times c of
n, which is theta of n log n.</p>
<p t="2306520" d="4529">So I've mixed in
constants c and thetas.</p>
<p t="2311049" d="1541">For the purposes of
this description,</p>
<p t="2312590" d="1360">they're interchangeable.</p>
<p t="2313950" d="4145">You will see recurrences that
look like this, in class.</p>
<p t="2325210" d="1650">And things like that.</p>
<p t="2326860" d="1510">Don't get confused.</p>
<p t="2328370" d="2780">It's just a constant
multiplicative factor</p>
<p t="2331150" d="3360">in front of the
function that you have.</p>
<p t="2334510" d="1720">And it's just a little
easier, I think,</p>
<p t="2336230" d="1910">to write down these
constant factors</p>
<p t="2338140" d="2370">and realize that the
amount of work done</p>
<p t="2340510" d="2470">is the same in
each of the leaves.</p>
<p t="2342980" d="3030">And once you know the
dimensions of this tree,</p>
<p t="2346010" d="2920">in terms of levels and in
terms of the number of leaves,</p>
<p t="2348930" d="2030">you get your result.</p>
<p t="2354560" d="2865">So we've looked at
two algorithm, so far.</p>
<p t="2366160" d="3380">And insertion sort, if
you talk about numbers,</p>
<p t="2369540" d="2424">is theta n squared for swaps.</p>
<p t="2371964" d="1166">Merge sort is theta n log n.</p>
<p t="2376270" d="2410">Here's another
interesting question.</p>
<p t="2378680" d="6040">What is one advantage of
insertion sort over merge sort?</p>
<p t="2390176" d="1004">AUDIENCE: [INAUDIBLE]</p>
<p t="2391180" d="1552">PROFESSOR: What does that mean?</p>
<p t="2392732" d="2041">AUDIENCE: You don't have
to move elements outside</p>
<p t="2394773" d="2187">of [INAUDIBLE].</p>
<p t="2396960" d="1460">PROFESSOR: That's exactly right.</p>
<p t="2398420" d="2910">That's exactly right.</p>
<p t="2401330" d="1940">So the two guys who
answered the questions</p>
<p t="2403270" d="2570">before with the levels, and you.</p>
<p t="2405840" d="1900">Come to me after class.</p>
<p t="2407740" d="1950">So that's a great answer.</p>
<p t="2409690" d="2490">It's in-place
sorting is something</p>
<p t="2412180" d="2640">that has to do with
auxiliary space.</p>
<p t="2414820" d="4460">And so what you see, here--
and it was a bit hidden, here.</p>
<p t="2419280" d="2660">But the fact of the
matter is that you</p>
<p t="2421940" d="3590">had L prime and R prime.</p>
<p t="2425530" d="4380">And L prime and R prime are
different from L and R, which</p>
<p t="2429910" d="3530">were the initial halves of
the inputs to the sorting</p>
<p t="2433440" d="1550">algorithm.</p>
<p t="2434990" d="3640">And what I said here is, we're
going to dump this into A.</p>
<p t="2438630" d="1810">That's what this picture shows.</p>
<p t="2440440" d="2900">This says sorted
array, A. And so you</p>
<p t="2443340" d="5380">had to make a copy of the
array-- the two halves L</p>
<p t="2448720" d="3550">and R-- in order to
do the recursion,</p>
<p t="2452270" d="2220">and then to take the
results and put them</p>
<p t="2454490" d="2300">into the sorted array, A.</p>
<p t="2456790" d="2430">So you needed-- in
merge sort-- you</p>
<p t="2459220" d="4840">needed theta n auxiliary space.</p>
<p t="2464060" d="6310">So merge sort, you need
theta n extra space.</p>
<p t="2470370" d="7010">And the definition
of in-place sorting</p>
<p t="2477380" d="4195">implies that you have theta
1-- constant-- auxiliary space.</p>
<p t="2484580" d="2750">The auxiliary space
for insertion sort</p>
<p t="2487330" d="3120">is simply that
temporary variable</p>
<p t="2490450" d="2860">that you need when
you swap two elements.</p>
<p t="2493310" d="2210">So when you want to swap
a couple of registers,</p>
<p t="2495520" d="2550">you gotta store one of the
values in a temporary location,</p>
<p t="2498070" d="1530">override the other, et cetera.</p>
<p t="2499600" d="3590">And that's the theta 1 auxiliary
space for insertion sort.</p>
<p t="2503190" d="4140">So there is an advantage of
the version of insertion sort</p>
<p t="2507330" d="1810">we've talked about,
today, over merge sort.</p>
<p t="2509140" d="3687">And if you have a billion
elements, that's potentially</p>
<p t="2512827" d="1833">something you don't
want to store in memory.</p>
<p t="2514660" d="2890">If you want to do something
really fast and do everything</p>
<p t="2517550" d="2850">in cache or main
memory, and you want</p>
<p t="2520400" d="3210">to sort billions are maybe
even trillions of items,</p>
<p t="2523610" d="4130">this becomes an
important consideration.</p>
<p t="2527740" d="5190">I will say that you can
reduce the constant factor</p>
<p t="2532930" d="1600">of the theta n.</p>
<p t="2534530" d="2060">So in the vanilla
scheme, you could</p>
<p t="2536590" d="2100">imagine that you have to
have a copy of the array.</p>
<p t="2538690" d="2210">So if you had n
elements, you essentially</p>
<p t="2540900" d="3590">have n extra items of storage.</p>
<p t="2544490" d="3640">You can make that n over 2
with a simple coding trick</p>
<p t="2548130" d="4580">by keeping 1/2 of A.</p>
<p t="2552710" d="3090">You can throw away one of
the L's or one of the R's.</p>
<p t="2555800" d="1837">And you can get it
down to n over 2.</p>
<p t="2557637" d="1833">And that turns out--
it's a reasonable thing</p>
<p t="2559470" d="1940">to do if you have
a billion elements</p>
<p t="2561410" d="3990">and you want to reduce your
storage by a constant factor.</p>
<p t="2565400" d="1730">So that's one coding trick.</p>
<p t="2567130" d="2500">Now it turns out that you
can actually go further.</p>
<p t="2569630" d="2500">And there's a fairly
sophisticated algorithm</p>
<p t="2572130" d="2610">that's sort of beyond
the scope of 6.006</p>
<p t="2574740" d="1680">that's an in-place merge sort.</p>
<p t="2579310" d="3760">And this in-place
merge sort is kind of</p>
<p t="2583070" d="5520">impractical in the sense
that it doesn't do very well</p>
<p t="2588590" d="1550">in terms of the
constant factors.</p>
<p t="2590140" d="4980">So while it's in-place and
it's still theta n log n.</p>
<p t="2595120" d="4600">The problem is that the running
time of an in-place merge sort</p>
<p t="2599720" d="3490">is much worse than the
regular merge sort that</p>
<p t="2603210" d="2300">uses theta n auxiliary space.</p>
<p t="2605510" d="2590">So people don't really
use in-place merge sort.</p>
<p t="2608100" d="1260">It's a great paper.</p>
<p t="2609360" d="2440">It's a great thing to read.</p>
<p t="2611800" d="5280">Its analysis is a bit
sophisticated for double 0 6.</p>
<p t="2617080" d="1950">So we wont go there.</p>
<p t="2619030" d="1300">But it does exist.</p>
<p t="2620330" d="1673">So you can take merge
sort, and I just</p>
<p t="2622003" d="3227">want to let you know that
you can do things in-place.</p>
<p t="2625230" d="5330">In terms of numbers, some
experiments we ran a few years</p>
<p t="2630560" d="4090">ago-- so these may not
be completely valid</p>
<p t="2634650" d="2000">because I'm going to
actually give you numbers--</p>
<p t="2636650" d="10730">but merge sort in Python, if
you write a little curve fit</p>
<p t="2647380" d="10410">program to do this, is 2.2n log
n microseconds for a given n.</p>
<p t="2657790" d="1835">So this is the
merge sort routine.</p>
<p t="2662450" d="9780">And if you look at
insertion sort, in Python,</p>
<p t="2672230" d="7180">that's something like 0.2
n square microseconds.</p>
<p t="2679410" d="3290">So you see the
constant factors here.</p>
<p t="2682700" d="5530">If you do insertion sort in C,
which is a compiled language,</p>
<p t="2688230" d="2190">then, it's much faster.</p>
<p t="2690420" d="2515">It's about 20 times faster.</p>
<p t="2695440" d="3790">It's 0.01 n squared
microseconds.</p>
<p t="2699230" d="1730">So a little bit of
practice on the side.</p>
<p t="2700960" d="1754">We do ask you to write code.</p>
<p t="2702714" d="916">And this is important.</p>
<p t="2703630" d="1300">The reason we're
interested in algorithms</p>
<p t="2704930" d="1840">is because people
want to run them.</p>
<p t="2706770" d="7090">And what you can see is that
you can actually find an n-- so</p>
<p t="2713860" d="2440">regardless of whether
you're Python or C,</p>
<p t="2716300" d="3720">this tells you that asymptotic
complexity is pretty important</p>
<p t="2720020" d="4120">because, once n gets
beyond about 4,000,</p>
<p t="2724140" d="3120">you're going to see that
merge sort in Python</p>
<p t="2727260" d="3090">beats insertion sort in C.</p>
<p t="2730350" d="5080">So the constant
factors get subsumed</p>
<p t="2735430" d="1730">beyond certain values of n.</p>
<p t="2737160" d="2675">So that's why asymptotic
complexity is important.</p>
<p t="2739835" d="1375">You do have a
factor of 20, here,</p>
<p t="2741210" d="2060">but that doesn't really
help you in terms</p>
<p t="2743270" d="4170">of keeping an n square
algorithm competitive.</p>
<p t="2747440" d="1960">It stays competitive
for a little bit longer,</p>
<p t="2749400" d="1110">but then falls behind.</p>
<p t="2754520" d="2867">That's what I wanted
to cover for sorting.</p>
<p t="2757387" d="1583">So hopefully, you
have a sense of what</p>
<p t="2758970" d="3070">happens with these two
sorting algorithms.</p>
<p t="2762040" d="3160">We'll look at a very different
sorting algorithm next time,</p>
<p t="2765200" d="3260">using heaps, which is a
different data structure.</p>
<p t="2768460" d="2870">The last thing I want to do in
the couple minutes I have left</p>
<p t="2771330" d="3480">is give you a little more
intuition as to recurrence</p>
<p t="2774810" d="3870">solving based on this diagram
that I wrote up there.</p>
<p t="2778680" d="2780">And so we're going to use
exactly this structure.</p>
<p t="2781460" d="2790">And we're going to look at a
couple of different recurrences</p>
<p t="2784250" d="2110">that I won't really
motivate in terms</p>
<p t="2786360" d="3060">of having a specific
algorithm, but I'll just</p>
<p t="2789420" d="1730">write out the recurrence.</p>
<p t="2791150" d="5190">And we'll look at the
recursion tree for that.</p>
<p t="2796340" d="5560">And I'll try and tease out of
you the complexity associated</p>
<p t="2801900" d="3735">with these recurrences of
the overall complexity.</p>
<p t="2809480" d="8520">So let's take a look at T
of n equals 2 T of n over 2</p>
<p t="2818000" d="2310">plus c n squared.</p>
<p t="2822820" d="5540">Let me just call that c--
no need for the brackets.</p>
<p t="2828360" d="2610">So constant c times n squared.</p>
<p t="2830970" d="2230">So if you had a
crummy merge routine,</p>
<p t="2833200" d="4820">and it was taking n square,
and you coded it up wrong.</p>
<p t="2838020" d="2030">It's not a great motivation
for this recurrence,</p>
<p t="2840050" d="3930">but it's a way this
recurrence could have come up.</p>
<p t="2843980" d="3490">So what does this
recursive tree look like?</p>
<p t="2847470" d="2110">Well it looks kind of
the same, obviously.</p>
<p t="2849580" d="3630">You have c n square; you
have c n square divided by 4;</p>
<p t="2853210" d="3410">c n square divided by
4; c n square divided</p>
<p t="2856620" d="4000">by 16, four times.</p>
<p t="2860620" d="3840">Looking a little bit
different from the other one.</p>
<p t="2864460" d="3100">The levels and the leaves
are exactly the same.</p>
<p t="2867560" d="2160">Eventually n is going
to go down to 1.</p>
<p t="2869720" d="3560">So you will see c
all the way here.</p>
<p t="2873280" d="1455">And you're going
to have n leaves.</p>
<p t="2877880" d="5500">And you will have, as
before, 1 plus log n levels.</p>
<p t="2883380" d="1690">Everything is the same.</p>
<p t="2885070" d="2520">And this is why I like this
recursive tree formulation so</p>
<p t="2887590" d="1780">much because, now,
all I have to do</p>
<p t="2889370" d="5340">is add up the work associated
with each of the levels</p>
<p t="2894710" d="2390">to get the solution
to the recurrence.</p>
<p t="2897100" d="1670">Now, take a look at
what happens, here.</p>
<p t="2898770" d="6580">c n square; c n square divided
by 2; c n square divided by 4.</p>
<p t="2905350" d="2540">And this is n times c.</p>
<p t="2910890" d="3426">So what does that add up to?</p>
<p t="2914316" d="1523">AUDIENCE: [INAUDIBLE]</p>
<p t="2915839" d="1041">PROFESSOR: Yeah, exactly.</p>
<p t="2916880" d="1040">Exactly right.</p>
<p t="2917920" d="2510">So if you look at what
happens, here, this dominates.</p>
<p t="2924340" d="3180">All of the other things are
actually less than that.</p>
<p t="2927520" d="1730">And you said bounded
by two c n square</p>
<p t="2929250" d="2170">because this part is
bounded by c n square</p>
<p t="2931420" d="3070">and I already have c n
square up at the top.</p>
<p t="2934490" d="3610">So this particular algorithm
that corresponds to this crummy</p>
<p t="2938100" d="4200">merge sort, or wherever
this recurrence came from,</p>
<p t="2942300" d="4400">is a theta n squared algorithm.</p>
<p t="2946700" d="3820">And in this case,
all of the work done</p>
<p t="2950520" d="4840">is at the root-- at the
top level of the recursion.</p>
<p t="2955360" d="2290">Here, there was a
roughly equal amount</p>
<p t="2957650" d="3980">of work done in each of
the different levels.</p>
<p t="2961630" d="4980">Here, all of the work
was done at the root.</p>
<p t="2966610" d="2850">And so to close
up shop, here, let</p>
<p t="2969460" d="4750">me just give you real
quick a recurrence where</p>
<p t="2974210" d="6260">all of the work is done at
the leaves, just for closure.</p>
<p t="2980470" d="5300">So if I had, magically, a merge
routine that actually happened</p>
<p t="2985770" d="2940">in constant time, either
through buggy analysis,</p>
<p t="2988710" d="3180">or because of it
was buggy, then what</p>
<p t="2991890" d="3760">does the tree look
like for that?</p>
<p t="2995650" d="2630">And I can think of
this as being theta 1.</p>
<p t="2998280" d="2876">Or I can think of this as
being just a constant c.</p>
<p t="3001156" d="874">I'll stick with that.</p>
<p t="3002030" d="3216">So I have c, c, c.</p>
<p t="3009890" d="1460">Woah, I tried to move that up.</p>
<p t="3011350" d="2400">That doesn't work.</p>
<p t="3013750" d="1795">So I have n leaves, as before.</p>
<p t="3018314" d="1666">And so if I look at
what I have, here, I</p>
<p t="3019980" d="1860">have c at the top level.</p>
<p t="3021840" d="4030">I have 2c, and so
on and so forth.</p>
<p t="3025870" d="1060">4c.</p>
<p t="3026930" d="4010">And then I go all
the way down to nc.</p>
<p t="3030940" d="2440">And so what happens
here is this dominates.</p>
<p t="3036010" d="5590">And so, in this recurrence, the
whole thing runs in theta n.</p>
<p t="3041600" d="4700">So the solution to
that is theta n.</p>
<p t="3046300" d="4670">And what you have here
is all of the work</p>
<p t="3050970" d="3480">being done at the leaves.</p>
<p t="3054450" d="3990">We're not going to really cover
this theorem that gives you</p>
<p t="3058440" d="3900">a mechanical way of figuring
this out because we think</p>
<p t="3062340" d="3440">the recursive tree is a
better way of looking at.</p>
<p t="3065780" d="3140">But you can see that, depending
on what that function is,</p>
<p t="3068920" d="3210">in terms of the work being
done in the merge routine,</p>
<p t="3072130" d="2360">you'd have different
versions of recurrences.</p>
<p t="3074490" d="2500">I'll stick around, and people
who answered questions, please</p>
<p t="3076990" d="1280">pick up you cushions.</p>
<p t="3078270" d="1970">See you next time.</p>
</body>
</timedtext>